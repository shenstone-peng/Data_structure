【基础知识】
有序度：数组中具有有序关系的元素对的个数。
```{.line-numbers}
  有序元素对：a[i]<=a[j] (i<j)
```
>举例：
{2,4,3,1,5,6}
有序对：{(2,4) (2,3) (2,5) (2,6)
(4,5) (4,6) (3,5) (3,6)
(1,5) (1,6) (5,6)}
所以有序度为11

【公式】逆序度=满有序度-有序度
我们排序的过程就是一种增加有序度，减少逆序度的过程，最后达到满有序度，就说明排序完成了。
# 冒泡排序
【原地排序】：冒泡的过程只涉及相邻数据的交换操作，只需要常量级的临时空间，  
所以它的空间复杂度为O（1），是原地算法。  
【稳定排序】：在冒泡排序中，只有交换才可以改变两个元素的前后顺序。为了保证  
冒泡排序算法的稳定性，当有相邻的两个元素大小相等的时候，我们不做交换，相同  
大小的数据在排序前后不会改变顺序，所以冒泡排序是稳定的排序算法。  
【时间复杂度】  
分析方法：
**时间复杂度** 可以通过求解（逆序度->有序度）的平均操作总数来得到。
举例：冒泡排序每交换一次，有序度加1。对n个数据的数组进行冒泡排序，平均交换次数是多少呢？最坏情况下，初始状态的有序度  
是0，所以要进行n*(n-1)/2次交换。最好情况下，初始状态的有序度是n*(n-1)/2,就不需要进行  
交换。我们可以取个中间值n*(n-1)/4，来表示初始有序度既不是很高也不是很低的平均情况。


```c++{.line-numbers}
void bubbleSort(vector<int> A){
        int size=A.size();
        bool flag=false;//判断是否需要继续排序
        for (int i=0; i<size; i++) {
            flag=false;
            for (int j=0;j<size-i-1;j++){
                if(A[j]>A[j+1]){
                    int tmp=A[j+1];
                    A[j+1]=A[j];
                    A[j]=tmp;
                    flag=true;
                }

            }
            if(!flag)break;
        }
    }
```
-----
# 插入排序
【原地排序】从实现过程可以很明显地看出，插入排序算法的运行并不需要额外的存储空间，所以空间复杂度是O(1)，也就是说，这是一个原地排序算法。
【稳定排序】在插入排序中，对于值相同的元素，我们可以选择将后面出现的元素，插入到前面出现元素  
后面，这样就可以保持原有的前后顺序不变，所以插入排序是稳定的排序算法。  
【时间复杂度】因为移动一次减少一点逆序度，所以平均时间复杂度还是O(n^2)
```c++{.line-numbers}
void insertionSort(vector<int> A){
    int size=(int)A.size();
    if(size<=1) return ;
    for(int i=1;i<size;i++){
        int tmp=A[i];
        int j=i-1;
        for(;j>=0;j--){
            if(A[j]>tmp){

                A[j+1]=A[j];

            }
            else break;
        }
        A[j+1]=tmp;
    }
}
```
---
# 选择排序
选择排序算法的实现思路有点类似插入排序，也分为已排序区间。但是选择排序每次会从排序区间找到最小的元素，将其放到已排序的末尾。
