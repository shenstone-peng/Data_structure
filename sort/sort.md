# 冒泡排序
【原地排序】：冒泡的过程只涉及相邻数据的交换操作，只需要常量级的临时空间，  
所以它的空间复杂度为O（1），是原地算法。
【稳定排序】：在冒泡排序中，只有交换才可以改变两个元素的前后顺序。为了保证  
冒泡排序算法的稳定性，当有相邻的两个元素大小相等的时候，我们不做交换，相同  
大小的数据在排序前后不会改变顺序，所以冒泡排序是稳定的排序算法。
【时间复杂度】
分析方法：
有序度：数组中具有有序关系的元素对的个数。
```{.line-numbers}
  有序元素对：a[i]<=a[j] (i<j)
```
>举例：
{2,4,3,1,5,6}
有序对：{(2,4) (2,3) (2,5) (2,6)
(4,5) (4,6) (3,5) (3,6)
(1,5) (1,6) (5,6)}
所以有序度为11


【公式】逆序度=满有序度-有序度
我们排序的过程就是一种增加有序度，减少逆序度的过程，最后达到满有序度，就说明排序完成了。
**时间复杂度**可以通过求解（逆序度->有序度）的平均操作总数来得到。
举例：冒泡排序每交换一次，有序度加1。对n个数据的数组进行冒泡排序，平均交换次数是多少呢？最坏情况下，初始状态的有序度  
是0，所以要进行n*(n-1)/2次交换。最好情况下，初始状态的有序度是n*(n-1)/2,就不需要进行  
交换。我们可以取个中间值n*(n-1)/4，来表示初始有序度既不是很高也不是很低的平均情况。


```c++{.line-numbers}
void bubbleSort(vector<int> A){
        int size=A.size();
        bool flag=false;
        for (int i=0; i<size; i++) {
            flag=false;
            for (int j=0;j<size-i-1;j++){
                if(A[j]>A[j+1]){
                    int tmp=A[j+1];
                    A[j+1]=A[j];
                    A[j]=tmp;
                    flag=true;
                }

            }
            if(!flag)break;
        }
    }
```
