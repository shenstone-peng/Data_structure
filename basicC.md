# 1基础部分
## 1.1基本语言
### 1.1.2 指针
1. C在编译时，每一个函数都有一个入口地址，该入口地址就是函数指针所指向一个具体的函数。这正如用指针变量可指向整型变量、字符型、数组一样，这里是指向函数。
2. 指向函数的指针一大用处是做回调函数
---
### 1.1.5函数
1. fork函数：在早期的Unix系统中，创建进程比较原始。当调用fork时，内核会把所有的内部数据结构复制一份，复制进程的页表项，然后把父进程的地址空间中的内容逐页的复制到子进程的地址空间中。但从内核角度来说，逐页的复制方式是十分耗时的。现代的UNIX系统采取了更多的优化，例如LINUX，采用了写时复制（COW），而不是对父进程空间进程整体的复制
2. 重载和重写的区别：
> 重载：两个函数名相同，但是参数列表不同（个数，类型），返回值类型没有要求，在同一作用域中
> 重写：子类继承了父类，父类中的函数是虚函数，这种情况是重写
3. strcpy是字符串拷贝函数，从src逐字节拷贝到dest，知道遇到'\0'结束，因为没有指定长度，可能会导致拷贝越界，造成缓冲区溢出漏洞，安全版本是strncpy函数。
4. strlen函数是计算字符串长度的函数，返回从开始到'\0'之间的字符个数。
5. 请你写个函数在main函数执行前执行
```c++
__attribute((constructor))void before()
{
	printf("before main\n");
}
```
6. C语言调用函数顺序：每个函数调用都会分配函数栈。在栈内进行函数执行过程。调用前，先把返回地址压栈，然后把当前函数的esp指针压栈。函数中参数的压栈顺序是从右到左。
7. 

### 1.1.6 宏定义
Q:用宏定义定义一年中有多少秒
A:
```c++
#define SECOND_PER_YEAR (60*60*24*365)UL
```
**U NEED KNOW**
- 要懂得预处理器将为你计算常熟表达式的值，比如这里不能直接写31536000
- 考虑这个表达式的值范围，会不会超过int，这里用UL标识为无符号长整型

----
Q:写一个标准宏MIN。这个宏输入两个参数并返回较小的一个
A:
```C++
#define MIN(A,B) ((A)>(B)?(B):(A))
```
**U NEED KNOW**
- 定义函数时一定要记得括号保护变量

### 1.1.7 const
1.
Q：const与define区别？
A：
“const常量具有类型，编译器可以进行安全检查；~~#define宏定义没有数据类型，只是简单的字符串替换~~，不能进行安全检查”
> 这个说法是错的，#define定义的宏变量同样存在类型，与字面值常量的类型相同。
正确答案：编译器不会将宏定义加入到符号列表中。

```c++
#define TEST 0  //int型
#define TEST2 128UL   //unsigned long型
#define TEST3 "hello"  //字符串型
#define TEST4 'Q'    //字符型
#define TEST5 3.13159f   //float型
```
---
2.
Q：全局作用域声明的const变量可以被其他文件访问吗？
A:
```c++
const int aa=1;  //不可以被其他文件访问
extern const int bb=2;    //可以被其他文件访问
```

>  普通变量（非const）默认为extern。要使const变量能够在其他的文件中访问，必须显式地指定它为extern。

----
3.其他重要点
- const对象必须要初始化，且不能修改
- 非const引用只能绑定到与该引用同类型对象。const引用则可以绑定到不同但相关的类型的对象或绑定到右值。 **原因**：因为const只读，不会修改引用原对象
- 由于上面的原因，应该将不修改相应实参的形参定义为const引用。如果将这样的形参定义为非const引用，则毫无必要的限制了该函数的使用。

```c++
int const *x;   //指向const int值的指针x
const int *x;    //同上
int *const x = &initializedVar;    //指向int值的const指针，必须初始化
const int *const x = &initializedVar; //指向const int 值的const指针，必须初始化
```
- 如果使用引用形参的唯一目的是避免复制实参，则应将形参定义为const引用
- 函数的非引用形参，对于调用时的参数是否为const无影响
- const成员函数不能修改调用该函数的对象，const对象只能访问const成员函数,而非const对象可以访问任意的成员函数,包括const成员函数。所以对不修改成员变量的成员函数，应该定义为const成员函数。构造函数不能声明为const函数


-----
### 1.1.8 static
1. 在data区存放已经初始化的全局静态变量，在bss区存放尚未初始化的全局静态变量，全部变量在main()外不需要写static。
2. 类中静态变量和外面的静态变量一样，由于声明为static的变量只被初始化一次，因为它们在单独的静态存储中分配了空间，因此类中的静态变量由对象共享。对于不同的对象，不能有相同静态变量的多个副本。也是因为这个原因，静态变量不能使用构造函数初始化。类中静态变量成员必须定义，因为声明的时候没有分配内存，定义可以给它分配内存，同时赋予了个初值；类中静态函数也同样不依赖于类对象，最好的调用方式为className::staticFucName();
```
class GamePlayer{
private:
	static const int NUM_Turns=5;   //声明的时候同时定义，因为静态常量变量只有一份拷贝，所以需要定义给它分配个内存
	int scores[NUM_TURNS];  //use of constant
	static print_hello(){cout<<"hello"<<endl;}
}
GamePlayer::print_hello();
}
```
3. 用static修饰的成员变量在对象中是不占内存的，因为他是不是跟对象一起在堆或栈中生成。
4. 加了static关键字的全局变量智能在本文件中使用。

### 1.1.9 sizeof
必须知道的
> - 空类的大小为1字节
> - 一个类中，虚函数本身、成员函数（包括静态与非静态）和静态数据成员都是不占用类对象的存储空间
>- 对于包含虚函数的类，不管有多少个虚函数，只有一个虚指针，vptr的大小
>- 虚函数继承，不管是单继承还是多继承，都是继承了基类的vptr，几个基类，几个vptr的长度
>- 虚继承，继承基类的vptr


----

### 1.1.10 goto
避免使用goto控制流
在一些函数中，我们可能需要在return 语句之前做一些清理工作，比如释放在函数开始处有malloc申请的内存空间，使用goto总是一种简单的方法：
```c++
int f(){
	int *p = (int *)malloc(sizeof(int));
	*p = 10;
	cout<<*p<<endl;
#ifndef DEBUG
	int error=1;
#endif
	if(error)
		goto END;//do something when go wrong
END:
	cout<<"need free the *p"<<endl;
	free(p);
	return 0;
}
```
但由于goto不符合软件工程的结构化，而且可能使得代码难懂，所以不提倡使用，这个时候我们可以使用do{...}while(0)来做同样的事情
```c++
int ff(){
	int *p = (int*)malloc(sizeof(int));
	*p = 10;
	cout<<*p<<endl;
	do{
#ifndef DEBUG
	int error=1;
#endif
	//do something
	if(error)
		break;  //if error, out
	}while(0);
	cout<<"free"<<endl;
	free(p);
	return 0;
}
```


### 1.1.11 extern
C++与C编译区别
>在C++中常在头文件见到extern "C"修饰函数，那有什么作用呢？ 是用于C++链接在C语言模块中定义的函数。
C++虽然兼容C，但C++文件中函数编译后生成的符号与C语言生成的不同。因为C++支持函数重载，C++函数编译后生成的符号带有函数参数类型的信息，而C则没有。
例如int add(int a, int b)函数经过C++编译器生成.o文件后，add会变成形如add_int_int之类的, 而C的话则会是形如_add, 就是说：相同的函数，在C和C++中，编译后生成的符号不同。
这就导致一个问题：如果C++中使用C语言实现的函数，在编译链接的时候，会出错，提示找不到对应的符号。此时extern "C"就起作用了：告诉链接器去寻找_add这类的C语言符号，而不是经过C++修饰的符号。

### 1.1.12inline(内联函数)
1. 需要知道的
- 类中内联，类中定义的函数是隐式内联函数，如果只声明不定义则需要在定义处加inline成为内联函数
- 内联优势：提高函数执行效率，调用函数的工作：调用前要先保存寄存器，并在返回时恢复；复制实参；程序还必须指向一个新位置执行。
- 内联劣势：如果函数体内的代码较长，内联会导致内存消耗代价比较高。
- 内联函数应该在头文件中定义。把内联函数的定义放在头文件中，可以确保在调用函数时所使用的定义是相同的。


2. 虚函数可以是内联函数吗？
- 虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联。
- 内联是在编译器建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联。
- inline virtual 唯一可以内联的时候是：编译器知道所调用的对象是哪个类（如 Base::who()），这只有在编译器具有实际对象而不是对象的指针或引用时才会发生。

---
### 1.1.13 union
> 联合（union）是一种节省空间的特殊的类，一个 union 可以有多个数据成员，但是在任意时刻只有一个数据成员可以有值。当某个成员被赋值后其他成员变为未定义状态。

---
### 1.1.14 四种cast转换
1. const_cast：用于将const变量转为非const
2. static_cast：用于各种隐式转换，比如非const转const，void\*转指针等，static_cast用于多态向上转化，如果能向下转能成功但是不安全，结果未知
3. dynamic_cast：用于动态类型转换。只能用于含有虚函数的类，用于类层次间的向上和向下转化。只能转指针或引用。向下转化时，如果是非法的对于指针返回NULL，对于引用抛异常。
4. reinterpret_cast：几乎什么都可以转，比如将int转指针，可能会出问题，尽量少用；
5. 为什么不用C的强制转换：C的强制转换表面上看起来功能强大什么都能转，但是转化不够明确，不能进行错误检查，容易出错。

---
### 1.1.15 智能指针
1. C++里面的四个智能指针：auto_ptr,shared_ptr,weak_ptr,unique_ptr其中后三个是C++11支持，并且第一个以及那个被11弃用。
2. 为什么要使用智能指针：智能指针的作用是管理一个指针，因为存在以下这种情况：申请的空间在函数结束时忘记释放，造成内存泄漏。使用智能指针可以很大程度上的避免这个问题。因为智能指针就是一个类，当超出了类的作用域时，类会自动调用析构函数，析构函数会自动释放资源
。所以智能指针的作用原理就是在函数结束时自动释放内存空间，不需要手动释放内存空间。
3. unique_ptr实现独占式拥有或严格拥有概念，保证同一时间内只有一个智能指针可以指向该对象。它对于避免资源泄漏（例如”以new创建对象后因为异常退出忘记释放对象）特别有用
4. shared_ptr实现共享式拥有概念。多个智能指针可以指向相同对象，该对象和其相关资源会在“最后一个引用被销毁”时候释放。资源被多个指针共享，它使用计数机制来表明资源被几个指针共享。可以通过成员函数use_count()来查看资源的所有者个数。除了可以通过new来构造，还可以通过传入另外三个智能指针来构造。当我们使用release()时，当前指针会释放资源所有权，计数减1。当计数等于0时，资源会被释放。

```c++
unique_ptr<string> p3(new string("auto"));
unique_ptr<string> p4;
p4 = p3;//error
```
### 1.2.2 顺序容器
1. **顺序容器**：将单一类型元素聚集起来成为容器，然后根据位置来存储和访问这些元素。（vector, list, deque）**适配器**：根据原始的容器类型所提供的操作，通过定义新的操作接口，来适应基础的容器类型。(stack, queue, priority_queue)
2. **默认构造函数**：所有容器类型都定义了默认构造函数，用于创建指定类型的空容器对象。默认构造函数不带参数。
3. **初始化**：
> 1将一个容器赋值给另一个容器时，类型必须匹配：容器类型和元素类型都必须相同
> 2用迭代器初始化，则不一定需要容器类型相同
```c++
vector<string> svec;
vector<string> svec2(svec);//ok  1
list<string> slist(svec);//err  1
list<string> slist2(svec);//ok  2
```
4. 容器元素类型必须满足以下两个约束。1元素类型必须支持赋值运算；2元素类型的对象必须可以复制。引用类型、标准IO和智能指针不能作为容器元素。
5. 关系操作符只适用于vector和deque，因为只有这两种容器为其元素提供快速、随机的访问
6. 在容器中添加元素时，系统是将元素值复制到容器里。被复制的原始值与新容器中的元素互不相关。因为容器在初始化的时候就分配了一定大小的内存空间，当添加元素时，只是把值复制进了容器中。
7. 不用将迭代器end赋值给临时对象，因为不管是添加还是删除操作，都会改变end指的值，而临时对象不会改变，即临时对象不是真正的end。
8. size指容器当前拥有的元素个数，而capacity指的是再下次分配内存前该容器可以存储的元素总数。
9. 所有适配器都定义了两个构造函数：默认构造函数用于创建空对象，而带一个容器参数的构造函数将参数容器的副本作为其基础值。默认的stack和queue都基于deque实现。
### 1.3.4 虚函数
1. 类的首地址是虚函数表地址，成员变量根据其继承和声明顺序依次放在后面，在单一继承中，被overwrite的虚函数在虚函数表中得到了更新
```c++
class Parent {
public:
    int iparent;
    Parent ():iparent (10) {}
    virtual void f() { cout << " Parent::f()" << endl; }
    virtual void g() { cout << " Parent::g()" << endl; }
    virtual void h() { cout << " Parent::h()" << endl; }

};

class Child : public Parent {
public:
    int ichild;
    Child():ichild(100) {}
    virtual void f() { cout << "Child::f()" << endl; }
    virtual void g_child() { cout << "Child::g_child()" << endl; }
    virtual void h_child() { cout << "Child::h_child()" << endl; }
};

class GrandChild : public Child{
public:
    int igrandchild;
    GrandChild():igrandchild(1000) {}
    virtual void f() { cout << "GrandChild::f()" << endl; }
    virtual void g_child() { cout << "GrandChild::g_child()" << endl; }
    virtual void h_grandchild() { cout << "GrandChild::h_grandchild()" << endl; }
};
```
```
 +-------+                            +-----------------------------------------------------+
0|       +----------------------->   0|GrandChild::f()                                      |
 | vfptr |                            +-----------------------------------------------------+
 +-------+                           1|Parent::g()                                          |
1|  10   |Parent.iparent              +-----------------------------------------------------+
 +-------+                           2|Parent::h()                                          |
2| 100   |Child.ichild                +-----------------------------------------------------+
 +-------+                           3|GrandChild::g_child()                                |
3|       |                            +-----------------------------------------------------+
 | 1000  |GrandChild.igrandchild     4|Child::h_child()                                     |
 +-------+                            +-----------------------------------------------------+
                                     5|GrandChild::h_grandchild()                           |
                                      +-----------------------------------------------------+
```
2. 多重继承（多个父类）：每个父类都有自己的续表，子类的成员函数被放到了第一个父类的表中，内存布局中，其父类布局一次按声明顺序排列。
3. https://www.cnblogs.com/qg-whz/p/4909359.html#_label6_0
4. 虚函数是动态绑定的，而缺省参数是静态绑定的
```c++
#include <iostream> 
using namespace std; 

class Base 
{ 
    public: 
        virtual void fun ( int x = 10 ) 
        { 
            cout << "Base::fun(), x = " << x << endl; 
        } 
}; 

class Derived : public Base 
{ 
    public: 
        virtual void fun ( int x=20 ) 
        { 
            cout << "Derived::fun(), x = " << x << endl; 
        } 
}; 


int main() 
{ 
    Derived d1; 
    Base *bp = &d1; 
    bp->fun();  // result:Derived::fun(), x = 10
    return 0; 
} 
```



### 1.3.5构造函数
1. 构造函数可以被重载，实参决定使用哪个构造函数，构造函数自动执行，用于const对象的构造函数。
2. 构造函数多一个初始化列表，在初始化列表中对类成员进行初始化，而在构造函数体里只是对成员进行赋值。如果初始化列表里没有，会调用该类型的默认构造函数进行初始化，然后在函数体里被重新赋值。
3. 初始化const或引用类型数据成员的唯一机会在构造函数初始化列表中。
```c++
class ConstRef {
public:
	ConstRef(int ii);
private:
	int i;
	const int ci;  //只能在初始化时进行赋值
	int &ri;  //只能在初始化时进行赋值
};
ConstRef::ConstRef(int ii):i(ii),ci(i),ri(ii){}
```

4. 构造函数初始化列表仅指定用于初始化成员的值，并不指定这些初始化执行的次序。成员被初始化的次序就是定义成员的次序。
5. explicit 修饰构造函数时，可以防止隐式转换和复制初始化


### 1.3.6析构函数
> 基类的析构函数必须为虚函数，在实现多态时，当用基类操作派生类，在析构时防止只析构基类而不析构派生类的状况发生。

---
### 1.3.7友元
> 友元提供了一种 普通函数或者类成员函数 访问另一个类中的私有或保护成员 的机制， 能访问私有成员 - 破坏封装性 - 友元关系不可传递 - 友元关系的单向性 - 友元声明的形式及数量不受限制


---
## 1.5编译与底层
### 1.5.1 编译机制
1. 对于C++源文件，从文本到可执行文件一般需要四个过程：
> 预处理阶段：对源代码文件中文件包含关系（头文件）、预编译语句（宏定义）进行分析和替换，生成预编译文件。
> 编译阶段：将经过预处理后的预编译文件转换城特定汇编代码，生成汇编文件
> 汇编阶段：将编译阶段生成的汇编文件转化成机器码，生成可重定位目标文件
> 链接阶段：将多个目标文件及所需要的库链接成最终的可执行目标文件
2. include头文件的顺序：对于include 的头文件来说，如果在a.h中声明一个在b.h中定义的变量，而没有引用b.h。那么要在a.c文件中引用b.h，并且要先引用b.h，后引用a.h，否则汇报变量类型未声明错误。
3. 使用" "，搜索头文件的顺序为：当前头文件目录-->编译器设置的头文件路径-->系统变量CPLUS_INCLUDE_PATH/C_INCLUDE_PATH指定的头文件路径
4. 使用<>，搜索头文件的顺序为：编译器设置的头文件路径-->系统变量CPLUS_INCLUDE_PATH/C_INCLUDE_PATH指定的头文件路径
---

# 2计算机网络
## 2.1网络概述
1. 五层网络协议
  ```c++


+----------------------+
|                      |
|      应用层           |  特殊进程之间特定的通信协议。（FTP/IMAP）
+----------------------+
|                      |
|      传输层           |  为计算机中不同进程之间的通信存在的协议。（TCP/UDP）
+----------------------+
|                      |
|      网络层           |  为识别不同网口（比如WIFI和以太网）的通信存在的协议。（IP）
+----------------------+
|                      |
|      连接层           |  信息以帧为单位传输。连接层协议的功能就是识别0/1序列中包含的帧。（以太网/WIFI）
+----------------------+
|                      |
|      物理层           |  通过将信号转换为1和0在媒介进行传输
+----------------------+

```

---
## 2.2 连接层
1. 以太网和WiFi是连接层的两种协议。信息以帧为单位传输。帧结构包括头部（序言、起始信号、目的地、发出地和类型）、数据和尾部（校验序列）

```c++
    content: Preamble |SFD|Destination|Source|Type|payload（data）|fcs|extension  
    bit :    ---7---- |-8-|6----------|6-----|16----------------  |   |
```
2. mac地址是物理设备自带的序号，只能在同一个以太网中被识别（正如邮差只熟悉自己的社区一样）

---
## 2.3网络层
1. IP包格式
```
    |-------------------------------------------------------- --- ------|  
    |-version-|-ihl--|-type of service-|--------total-length------------|  
    |------identificaiton--------------|-flags-|-fragment offset------- |  
    |-time-to-live---| protocol        | header checksum----------------|  
    |--------------------source address--------------------------- -----|  
    |-----------------------destination address------------------- -----|  
    |---------options--------------------- --|---- -----padding---------|  
    |-----------------------------data--------------------------------- |
```
2. IP协议像是接力棒，通过路由表判断将信息送到哪个网卡。
3. ARP协议：找到IP地址和MAC的对应关系
4. RIP协议：智能拓展routing table
---
## 2.4传输层协议
###  2.4.1 TCP [学习源地址](https://coolshell.cn/articles/11564.html) [学习源地址2](https://www.cnblogs.com/linguoguo/p/10519635.html)
1. tcp包
> sequence number是包的序号，用来解决网络包乱序(reordering)问题。 
> Acknowledgement Number就是ACK——用于确认收到，用来解决不丢包的问题。
>  Window又叫Advertised-Window，也就是著名的滑动窗口(Sliding Window)，用于解决流控的。
>   TCP Flag也就是包的类型，主要是用于操控TCP的状态机的。
2. TCP的状态机
> 网络上的传输是没有连接的，包括TCP也是一样的。而TCP所谓的“连接”，其实只不过是在通讯的双方维护一个“连接状态”，让它看上去好像有连接一样。
```c++
                          +--------------+
                          |              |
       +------------------+   CLOSED     +--------------+
       |                  +--------------+              |
       |                                                |
       |                                                |
       |Passive Open                                    |
       |Set Up TCB                                      |
       |                                                |
       |                                                |
       v                                     Active Open Set Up TCB
+------+-------+                                  Send SYN
|              |        <-------------------------------| connect()
|   LISTEN     |listen()        SYN  seq=x              |
+-----+--------+                                        |
      |                                                 |
      |                                                 |
      | Receive SYN    +---------------------------->   |
      | Send SYN+ACK       SYN seq=y ACK=x+1            |
      |                                                 |
      |                                                 v
+-----v---------+       Simultaneous Open         +-----+-------+
|               |     Receive SYN Send ACK        |             |
| SYN-RECEIVED  +<--------------------------------+ SYN-SENT    |
+-------+-------+                                 +-----+-------+
        |             <------------------------+        |
        |                  ACK=y+1                      |
        |                                               |
        |Receive ACK                                    |Receive SYN+ACK
        |                                               |Send ACK
        |                                               |
        |              +-------------------+            |
        |              |                   |            |
        +------------->+   ESTABLISHED     +<-----------+
                       +-------------------+
                         |      |
      FIN seq=x+2 ACK=y+1|      |         Recei^e FIN Send ACK=x+3
           +-------------+      +----------------+
           |   close()                           |
    +------v-------+                      +------v-------+
    |  FIN-WAIT-1  |                      |  CLOSE-WAIT  |
    +---+------+---+                      +--------------+
        |      |                                  |
        |      |                                  |
        |      |                                  |
        |      |  Recieve Fin Send ACK            |
        |      +------------+                     |Wait for Application Close
        |                   |                     |  Send FIN
Receive ACK for FIN         |                     |
        ^                   v                     v
   +----+--------+      +---+---------+   +-------+----+
   |  FIN-WAIT-2 |      |  CLOSING    |   |  LAST-ACK  |
   +-------------+      +---+---------+   +---------+--+
 Receive FIN                |                       |
    Send ACK                |Receive ACK for FIN    |
        |     +-------------v+                      v
        +-----> TIME-WAIT    |                    +-+-------------+
              |              +------------------->+               |
              +--------------+                    |    CLOSED     |
                                                  +---------------+


```
3. 当server端socket在SYN-RECEIVED状态时，client端断链了，会重试发SYN-ACK，时间间隔为1s,2s,4s,8s,16s，总共31s，第5次发出后等待32s，如果没有回复就会断开这个链接。
> **关于SYN FLOOD攻击**：给服务器发一个SYN就下线，于是服务器需要默认等待63s才会断开连接，这样就可以把服务器的syn连接的队列耗尽，让正常的连接请求不能处理。
> **解决方案**：Linux下给了一个叫tcp_syncookies的参数来应对这个事——当SYN队列满了之后，TCP会通过源地址端口、目标地址端口和时间戳打造出一个特别的Sequence Number发回去（又叫cookie），如果是攻击者则不会有响应，如果是正常连接，则会把这个SYN Cookie发回来，然后服务端可以通过cookie建连接（即使不在SYN队列中）；tcp_synack_retries参数减少重试次数；tcp_max_syn_backlog参数增大SYN连接数；tcp_abort_on_overflow参数实在处理不过直接拒绝连接
4. **关于ISN的初始化**：ISN不能hard code，会在网络不稳定时，接收端无法确定包的顺序和是否有用。RFC793里规定，ISN会和一个假的时钟绑在一起，这个时钟会在每4微妙对ISN做加1的操作，直到超过2^32，又从0开始。这样一个ISN的周期大约是4.55小时，因为我们假设我们的TCP Segment在网络上的存活时间不会超过Maximum Segment Lifetime，所以只要MSL的值小于4.55小时，那么我们就不会重用到ISN。
5. **关于MSL和TIME_WAIT**：最后发出ACK，肯定要想一下对面有没有收到啊，因为TCP Segment最迟会花费1个MSL送到对面，如果对面1个MSL都没收到你的ACK，对面就会再次发一个FIN给你，就又得等1个MSL。一来一回，两个MSL，所以在发出ACK后，会进入TIME_WAIT状态，等待2个MSL时间，socket状态才会CLOSED。
6. **超时重传机制** ：在未收到该收到的包后，就不发ACK，知道发送端发觉TIME OUT后，重传缺失的包。**问题**：等待timeout 时间太久，也不知道要重传哪些包，可能会浪费带宽
7. **快速重传机制**：Fast Retransmit，接收端在未收到该收到的包后，会重复发上一个接收的包的ACK，连发三次后，发送端知道这个包没收到，会重发。**问题**解决了不需要等待timeout，但还是没解决不知道要重传哪些包的问题。
8. **SACK方法**：这种方式在TCP头里加一个SACK的东西，ACK还是Fast Retransmit的ACK，SACK则是汇报接收到的数据碎版。
9. **TCP的RTT算法**：RTT是一个数据包从发出去到回来的时间。RTO（Retransmission Time Out）超时时间
> **经典算法** ：每次采样RTT值，便与SRTT加权求出新的SRTT。缺陷：很难处理重传时候的RTT值。
> **Karn/Partrigdge**算法：忽略重传，不把重传的RTT做采样，如果遇到重传直接double rto值。缺陷：这种死规矩对于一个需要估计比较准确的RTT不靠谱。
> **Jacobson/Karels**:消除当RTT有大波动的情况
10. **TCP滑动窗口**：TCP头里有一个字段叫Window，又叫Advertised-Window，这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。
11. **TCP的拥塞处理**：如果网络上的延时突然增加，那么，TCP对这个事做出的应对只有重传数据，但是，重传会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，于是，这个情况就会进入恶性循环被不断的放大。
> **慢启动**：window一开始很小，然后每成功传输一次，窗口大小加1，每过一个RTT时间，窗口大小double。说是慢启动，但当网络情况好的时候，速度很快就上来了，因为网络情况好，收到ACK的时间快，收到ACK的时间短，所以RTT时间就短，window大小就一直double。
> **拥塞避免算法**：当window到一个很大的值后（ssthresh=65535字节），会慢慢增长，不再会直接double。
> **拥塞状态算法**：当重传发生时，会重置window窗口大小为1，然后重新开始慢启动，不同的是，ssthresh会减半。
> **快速恢复算法**：一般与快速重传算法一起使用，当收到3个Duplicated ACK后，说明网络也没那么糟糕，调整窗口为（sshthresh+3*MSS）。
> **FACK算法**：用来做SACK重传过程中的拥塞流控。
12. **SYN队列**：SYN队列存储了收到SYN包的连接，它的职责是回复SYN+ACK包，并且在没有收到ACK包时重传，直到超时。发送完SYN+ACK后，SYN队列等待从客户端发出的ACK包。当收到ACK包时，首先找到对应的SYN队列，再在对应的SYN队列中检查相关的数据看是否匹配。内核将该连接相关的数据从SYN队列中移除，创建一个完整的连接，并将这个连接加入到Accept队列。
13. **Accept队列**：Accept队列中存放的是已建立好的连接，也即等待被上层应用程序取走的连接。当进程调用accpet()，这个socket从队列中取出，传递给上层应用程序。
14. **队列大小设置多少合适**：看情况，对于大多数的TCP服务来说，这并不重要。尽管如此也存在一些合理的原因，需要增大队列的大小
> 当建立连接的请求速度缺失很大时，即使是对于一个高性能的服务来说，SYN队列也可能需要设置的大一些。
> SYN队列的大小，换言之就是等待ACK包的连接数。也即与客户端的平均往返时间越大，堆积在SYN队列中的连接就越多。对于那些大部分客户端都距离服务器很远的场景。比如说往返时间几百毫秒以上，可以将队列大小设置的大一些。
> TCP_DEFER_ACCPET选项如果打开了，会导致socket在SYN-RECV状态下维持更长的时间，也即增大了处于SYN队列中的时间。
> 队列设置太大的缺点：syn队列中的每一个槽位都需要占用一些内存。当遇到SYN_Flood攻击时，我们没必要为这些发起攻击的包浪费资源。SYN队列中的inet_request_sock结构体，在4.14内核下，每个将占用256字节的内存。
15. **查看socket状态命令**：
```bash
ss -n state syn-recv sport=:80|wc -l    
#查看80端口处于syn-recv状态的socket数量
```

---
 # 3 操作系统
## 3.1操作系统概论
### 3.1.1虚拟内存
1. 虚拟内存是操作系统物理内存和进程之间的中间层，它为进程隐藏了物理内存这一概念，为进程提供了更加简洁和易用的接口以及更加复杂的功能。
2. 操作系统以页为单位管理内存，当进程发现需要访问的数据不在内存时，操作系统可能会将数据以页的方式加载到内存中，这个过程是由MMU完成的。
3. 虚拟内存的关键作用
> 虚拟内存可以利用磁盘起到缓存的作用，提高进程访问磁盘的速度；
> 虚拟内存可以为进程提供独立的内存空间，简化程序的链接、加载过程并通过动态库共享内存
> 虚拟内存可以控制进程对物理内存的访问，隔离不同进程的访问权限，提供系统的安全性。
4. 当用户程序访问未被缓存的虚拟页时（即没有被缓存到物理内存中的数据），硬件就会触发缺页中断（Page Fault,PF），一种情况：被访问的页面已经加载到了物理内存中，但用户程序的页表（Page Table）并不存在该对应关系，这时我们只需要在页表中建立虚拟内存到物理内存的关系；另一种情况：操作系统需要将磁盘上未被缓存的虚拟页加载到物理内存中。
5. 在Linux调用fork创建子进程时，实际上只复制了父进程的页表，当父进程或者子进程对共享的内存进行修改时，共享的内存才会以页为单位进行拷贝，父进程会保留原有的物理空间，而子进程会使用拷贝后的物理空间。
